import { mkdirSync, writeFileSync, readFileSync, existsSync, rmSync } from 'fs';
import { dirname, resolve } from 'path';
import http from 'http';
import { spawn } from 'child_process';

function makeID() {
  return Date.now().toString(36) + Math.random() * 100;
}

function writeFile(file, data) {
  mkdirSync(dirname(file), { recursive: true });
  writeFileSync(file, data);
}

function escapePHP(inputFile, outputFile) {
  const input = readFileSync(inputFile).toString();
  const codeTokens = {};
  const isJS = inputFile.includes(".js") || inputFile.includes(".ts");
  const isML = inputFile.includes(".php") || inputFile.includes(".htm");
  const out = input.replaceAll(/<\?(?:php|).+?\?>/gis, (match) => {
    let token = makeID();
    if (isJS) {
      token = `/*${token}*/`;
    } else if (isML) {
      token = `<!--${token}-->`;
    }
    codeTokens[token] = match;
    return token;
  });
  writeFile(outputFile + ".json", JSON.stringify(codeTokens));
  writeFile(outputFile, out);
}
function unescapePHP(file, tokensFile) {
  const input = readFileSync(file).toString();
  let out = input;
  const tknsFile = tokensFile || file + ".json";
  if (existsSync(tknsFile)) {
    const codeTokens = JSON.parse(readFileSync(tknsFile).toString());
    Object.entries(codeTokens).forEach(([token, code]) => {
      out = out.replace(token, (match) => {
        return `${code}`;
      });
    });
  }
  return out;
}

function start(root) {
  if (!globalThis.php?.pid) {
    const routerFileUrl = new URL("./router.php", import.meta.url);
    globalThis.php = spawn(phpServer.binary, [
      "-S",
      "localhost:" + phpServer.port,
      "-t",
      root,
      decodeURI(routerFileUrl.pathname)
    ]).once("spawn", () => {
      console.log(
        `PHP development server started (PID: ${globalThis.php?.pid})`
      );
    }).on("error", (error) => {
      console.error("PHP dev-server error: " + error.message);
    }).on("close", (code) => {
      console.log(`PHP development server stopped (Code: ${code})`);
    });
  }
}
function stop() {
  if (globalThis.php) {
    globalThis.php.stdin?.end();
    globalThis.php.stdout?.destroy();
    globalThis.php.stderr?.destroy();
    if (globalThis.php.kill()) {
      console.log("PHP development server killed");
    } else {
      console.error("Attention! Failed to kill PHP development server!");
    }
  }
}
const phpServer = {
  binary: "php",
  port: 65535,
  start,
  stop
};

function usePHP(cfg = {}) {
  const {
    binary = "php",
    entry = "index.php",
    tempDir = ".php-tmp",
    cleanup = {}
  } = cfg;
  const { dev: devCleanup = true } = cleanup;
  phpServer.binary = binary;
  let config = void 0;
  let viteServer = void 0;
  const entries = Array.isArray(entry) ? entry : [entry];
  function escapeFile(file) {
    const tempFile = `${tempDir}/${file}.html`;
    escapePHP(file, tempFile);
    return tempFile;
  }
  function cleanupTemp(dir = "") {
    const parentDir = dir ? dir + "/" : dir;
    rmSync(parentDir + tempDir, { recursive: true, force: true });
  }
  function onExit() {
    if (config?.command === "serve") {
      phpServer.stop();
      devCleanup && cleanupTemp();
    }
    process.exit();
  }
  [
    "exit",
    "SIGINT",
    "SIGUSR1",
    "SIGUSR2",
    "uncaughtException",
    "SIGTERM"
  ].forEach((eventType) => {
    process.on(eventType, onExit.bind(null));
  });
  return [
    {
      name: "prepare-php",
      config: {
        order: "post",
        handler(config2, env) {
          const gitIgnoreFile = `${tempDir}/.gitignore`;
          if (!existsSync(gitIgnoreFile)) {
            writeFile(gitIgnoreFile, "*\n**/*.php.html");
          }
          const inputs = entries.map(escapeFile);
          return {
            build: {
              rollupOptions: { input: inputs }
            },
            optimizeDeps: { entries: inputs }
          };
        }
      },
      configResolved(_config) {
        config = _config;
      }
    },
    {
      name: "serve-php",
      apply: "serve",
      enforce: "pre",
      configureServer(server) {
        viteServer = server;
        phpServer.start(viteServer?.config.root);
        server.middlewares.use(async (req, res, next) => {
          try {
            if (req.url) {
              const url = new URL(
                req.url,
                "http://localhost:" + phpServer.port
              );
              let requestUrl = url.pathname;
              if (requestUrl.endsWith("/")) {
                requestUrl += "index.php";
              }
              requestUrl = requestUrl.substring(1);
              const entry2 = entries.find((file) => {
                return file === requestUrl || file.substring(0, file.lastIndexOf(".")) === requestUrl;
              });
              if (entry2) {
                const tempFile = `${tempDir}/${entry2}.html`;
                if (existsSync(resolve(tempFile))) {
                  url.pathname = tempFile;
                  const phpResult = await new Promise(
                    (resolve2, reject) => {
                      http.request(
                        url.toString(),
                        {
                          method: req.method,
                          headers: req.headers
                        },
                        (msg) => {
                          msg.on("data", resolve2);
                        }
                      ).on("error", reject).end();
                    }
                  );
                  let out = phpResult.toString();
                  out = await server.transformIndexHtml(
                    requestUrl || "/",
                    out
                  );
                  res.end(out);
                  return;
                }
              }
            }
          } catch (error) {
            console.error(`Error: ${error}`);
          }
          next();
        });
      },
      handleHotUpdate({ server, file }) {
        const entry2 = entries.find(
          (entryFile) => file.endsWith(entryFile) && resolve(entryFile) === file
        );
        if (entry2) {
          escapeFile(entry2);
          server.ws.send({
            type: "full-reload",
            path: "*"
          });
        }
      }
    },
    {
      name: "build-php",
      apply: "build",
      resolveId(source, importer, options) {
        if (importer?.endsWith(".html") && importer.includes(`/${tempDir}/`)) {
          return { id: resolve(source) };
        }
      },
      closeBundle() {
        const distDir = config?.build.outDir;
        entries.forEach((file) => {
          const code = unescapePHP(
            `${distDir}/${tempDir}/${file}.html`,
            `${tempDir}/${file}.html.json`
          );
          writeFile(`${distDir}/${file}`, code);
        });
        cleanupTemp(distDir);
      }
    }
  ];
}

export { usePHP as default };
